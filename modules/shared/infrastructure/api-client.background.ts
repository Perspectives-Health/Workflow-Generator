import { config } from "@/modules/shared/config";
import createClient, { Middleware } from "openapi-fetch";
import type { paths } from "../schema"; // generated by openapi-typescript
import { cloneRequestForRetry, getAuthToken, getSession, refreshAuthSession } from "@/modules/auth/auth.utils";


export enum HttpStatus {
    BAD_REQUEST = 400,
    UNAUTHORIZED = 401,
    FORBIDDEN = 403,
    NOT_FOUND = 404,
    CONFLICT = 409,
    UNPROCESSABLE_ENTITY = 422,
    INTERNAL_SERVER_ERROR = 500,
    BAD_GATEWAY = 502,
    SERVICE_UNAVAILABLE = 503,
}

/**
* Lightweight API Error for server-returned errors
* Directly reflects API error responses like { error: "CODE", message: "description" }
*/
export class ApiError extends Error {
    public error: string;
    public statusCode: number;
    public response: Response;
    public data: Record<string, unknown>;

    constructor(
        error: string,
        message: string,
        statusCode: number,
        response: Response,
        data: Record<string, unknown> = {}
    ) {
        super(message);
        this.name = "ApiError";
        this.error = error;
        this.statusCode = statusCode;
        this.response = response;
        this.data = data;
    }

    /** Check if an unknown error is an ApiError */
    static isApiError(error: unknown): error is ApiError {
        return error instanceof ApiError;
    }
}

/**
 * Auth middleware implementation that handles authentication and token refresh.
 * Whenever a request is made, cache the request body for potential retry.
 * If a 401 error is encountered, attempt to refresh the auth session.
 * 
 * POST /refresh should not be retried. 
 *     401 on /refresh should be handled by logging out the user and opening login popup.
 *     This is implemented not in the middleware but in the refreshToken function in auth.api.background.ts
 * 
 * 
**/

const retryBodies = new WeakMap<Request, Blob>();

const INVALID_TOKEN_ERROR_MESSAGES = [
    'invalid token',
    'invalid or expired token'
]

const authMiddleware: Middleware = {
    async onRequest({ request, options }) {
        const accessToken = await getAuthToken();
        if (accessToken) {
            request.headers.set("Authorization", `Bearer ${accessToken}`);
        } else {
            console.error("No auth token found");
        }

        // Cache body for potential retry
        if (request.body) {
            const bodyClone = request.clone();
            const bodyBlob = await bodyClone.blob();
            retryBodies.set(request, bodyBlob);
        }

        return request;
    },
    async onResponse({ request, response, options }) {

        if (response.status === 401) {
            // Skip retry for refresh endpoint.
            // /refresh should not be retried. 401 on /refresh should be handled by logging out the user and opening login popup.
            if (request.method === 'POST' && request.url.endsWith('/refresh')) {
                console.log("401 on refresh endpoint, not retrying");
                retryBodies.delete(request);
                return response;
            }

            console.warn("Unauthenticated - checking if request should be retried");
            const responseClone = response.clone();

            try {
                const data = await responseClone.json();
                const errorMessage = data?.detail.toLowerCase();

                const isInvalidTokenError = INVALID_TOKEN_ERROR_MESSAGES.some(
                    msg => errorMessage.includes(msg)
                );

                if (!isInvalidTokenError) {
                    console.log("401 error is not an invalid token error, not retrying");
                    retryBodies.delete(request);
                    return response;
                }

                const newSession = await refreshAuthSession();
                if (newSession && newSession.access_token) {
                    const retryRequest = cloneRequestForRetry(
                        request,
                        retryBodies.get(request) ?? null,
                        newSession.access_token
                    );
                    const retryResponse = await fetch(retryRequest);

                    // If retry was successful, return the new response
                    if (retryResponse.ok) {
                        return retryResponse;
                    } else {
                        throw new Error("Request retry failed with status: " + retryResponse.status);
                    }
                } else {
                    throw new Error("Failed to refresh auth session - no valid session or token returned");
                }
            } catch (error) {
                console.error("Error during auth session refresh and retry:", error);
                // If refresh fails, we should not retry and let the original 401 response through
                return response;
            } finally {
                retryBodies.delete(request);
            }
        }

        // Clean up if no retry was needed
        retryBodies.delete(request);

        return response;
    },
};
const loggingMiddleware: Middleware = {
    async onRequest({ request, options }) {
        return request;
    },
    async onResponse({ request, response, options }) {
        const { body, ...resOptions } = response;
        return response;
    },
    async onError({ error }) {
        console.error("API Error:", error);
        return;
    },
};

const errorMiddleware: Middleware = {
    async onResponse({ response }) {
        if (!response.ok) {
            const data = await response.clone().json();
            throw new ApiError(
                data?.error || "UNKNOWN_ERROR",
                data?.message || `HTTP ${response.status}`,
                response.status as HttpStatus,
                response,
            );
        }
        return response;
    },
};


export const fastapi = createClient<paths>({ baseUrl: config.apiUrl });

fastapi.use(loggingMiddleware);
fastapi.use(errorMiddleware);
fastapi.use(authMiddleware);
